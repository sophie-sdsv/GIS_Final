[["index.html", "Guidebook Chapter 1 Introduction and Data Description", " Guidebook Sophie Fung Chapter 1 Introduction and Data Description This document will guide you through the steps to produce a network analysis in R to examine the changes of Santander bikes usage between the monthly period of August 2019 and August 2020. List data involved: Bike journey data Here August 2019 August 2020 Bike station locations Data here For convenience, I uploaded the merged csv and the station data to my drive, download the data bundle here "],["intro.html", "Chapter 2 Data Processing 2.1 Bike Journey data 2.2 Station data", " Chapter 2 Data Processing 2.1 Bike Journey data First, we need to merge the data together to a csv I used Python to merge and filter the data I followed a script found online to merge files with the same schema into one file After merging, we need to format the dates to machine readable format df2[&quot;End_Date&quot;] = pd.to_datetime(df2[&quot;End_Date&quot;], format = &quot;%d/%m/%Y %H:%M&quot;) df2[&quot;Start_Date&quot;] = pd.to_datetime(df2[&quot;Start_Date&quot;], format = &quot;%d/%m/%Y %H:%M&quot;) Then we need to filter the dates out df2[(df2[&#39;End_Date&#39;]&gt;&#39;2019-08-01&#39;) &amp; (df2[&#39;End_Date&#39;]&lt;&#39;2019-09-01&#39;)] Lastly, output to csv df3.to_csv(&quot;filtered.csv&quot;) Now we have the monthly report for both August 2019 and 2020 2.2 Station data Load the libraries: library(dplyr) library(dlookr) library(tidyr) library(lubridate) In R, we need to stick the coordinates of the stations to the journey data using right join Load the datasets: station &lt;- read.csv(&quot;stations.csv&quot;) aug_2019 &lt;- read.csv(&quot;filtered_aug2019.csv&quot;) aug_2020&lt;- read.csv(&quot;filtered_aug2020.csv&quot;) Now, we first stick the coordinates of the destination data, drop unnecessary columns, and rename the coordinates to distinguish between origin and destination data, then filter away the rows with NA in the rental IDs and export as .csv We do the same to the 2020 data as well aug_2019_end &lt;- right_join(aug_2019,station, c(&quot;EndStation_Id&quot; = &quot;Station.Id&quot;)) aug_2019_end &lt;- aug_2019_end %&gt;% select(-c(EndStation_Name,StartStation_Name,StationName,Easting,Northing)) aug_2019_end &lt;- aug_2019_end %&gt;% relocate(longitude, latitude, .after = EndStation_Id) aug_2019_end &lt;- aug_2019_end%&gt;% rename( d_longitude = longitude, d_latitude = latitude ) aug_2019_cor &lt;- right_join(aug_2019_end,station, c(&quot;StartStation_Id&quot; = &quot;Station.Id&quot;)) %&gt;% select(-c(StationName,Easting,Northing)) %&gt;% rename( o_longitude = longitude, o_latitude = latitude ) aug_2019_cor&lt;- aug_2019_cor %&gt;% filter(!is.na(Rental_Id)) write.csv(aug_2019_cor,&quot;aug_2019_cordinates.csv&quot;, row.names = FALSE) We now have to get divide the monthly data by weekdays and weekends, in the end we will have 4 datasets #get weekdays aug_2019_weekday &lt;- aug_2019_cor %&gt;% filter(Start_Date!=End_Date)%&gt;% mutate(weekday = wday(Start_Date,label = TRUE)) %&gt;% filter(!wday(Start_Date) %in% c(1,7)) #get weekends aug_2019_weekend &lt;- aug_2019_cor %&gt;% filter(Start_Date!=End_Date)%&gt;% mutate(weekday = wday(Start_Date,label = TRUE)) %&gt;% filter(wday(Start_Date) %in% c(1,7)) After that, we will now count the occurrence of paired trips (ie. the number of trips from point A to point B), we will need to do this for all 4 datasets #now have to get the trips per point pair pair_aug2019_weekday &lt;- aug_2019_weekday %&gt;% group_by(StartStation_Id, EndStation_Id) %&gt;% mutate(n=n()) %&gt;% arrange(desc(n), .by_group=FALSE) %&gt;% distinct(StartStation_Id, EndStation_Id,n, .keep_all=TRUE) %&gt;% relocate(StartStation_Id,EndStation_Id, n,.before=X) pair_aug2019_weekend &lt;- aug_2019_weekend %&gt;% group_by(StartStation_Id, EndStation_Id) %&gt;% mutate(n=n()) %&gt;% arrange(desc(n), .by_group=FALSE) %&gt;% distinct(StartStation_Id, EndStation_Id,n, .keep_all=TRUE) %&gt;% relocate(StartStation_Id,EndStation_Id, n,.before=X) Yikes now the preparation work is done, we will move on to computing the network! "],["creating-networks.html", "Chapter 3 Creating networks 3.1 Igraph object", " Chapter 3 Creating networks We will be using the igraph package to compute the networks, after that we will extract its contents so that the network can be plotted onto a interactive map leaflet. 4 network objects will be produced: Weekdays 2019, 2020 and weekends 2019, 2020 3.1 Igraph object Loading libraries library(spatstat) library(sp) library(sf) library(tmaptools) library(stringr) library(stplanr) library(tidyr) library(dplyr) library(igraph) library(leaflet) library(leafpop) library(grDevices) library(colorspace) First, we need to reduce the station dataset, latitude and longitude are already in EPSG:4326 format so we do not need to reproject it staion_cord &lt;- data.frame(&quot;Staion&quot;= station$Station.Id, &quot;lat&quot;=station$latitude,&quot;lon&quot;=station$longitude) Next we extract some things from the paired trip dataset, and filter out loop trips (ie. start station = end station), we will also limit the flow amount to above 20 (ie. at least 20 trips between the 2 stations), do this for all 4 datasets inter_mvmt_net_2019_wkday_reduced &lt;- pair_aug2019_weekday %&gt;% select(StartStation_Id,EndStation_Id,n) %&gt;% filter(StartStation_Id!=EndStation_Id) %&gt;% filter(n&gt;20) Convert to igpaph object: G1 &lt;- graph.data.frame(inter_mvmt_net_2019_wkday_reduced, directed=T, vertices = staion_cord) After all 4 networks are created, we will stick the degree information for all vertices, then extract the vertices and edges information # append degree information V(G1)$deg &lt;- degree(G1, mode = &quot;all&quot;) network_extract &lt;-get.data.frame(G1, &quot;both&quot;) vert&lt;- network_extract$vertices coordinates(vert) &lt;- ~ lon + lat #edges are the lines connecting the stations, we will extract them as SpatialLine objects for plotting edges&lt;-network_extract$edges edges&lt;-lapply(1:nrow(edges), function(i) { as(rbind(vert[vert$name == edges[i, &quot;from&quot;], ], vert[vert$name == edges[i, &quot;to&quot;], ]), &quot;SpatialLines&quot;) }) for (i in seq_along(edges)) { edges[[i]] &lt;- spChFIDs(edges[[i]], as.character(i)) } edges &lt;- do.call(rbind, edges) Now we have 4 vertices, 4 edges, and 4 network extract datasets, we can add them to the map now! "],["leaflet.html", "Chapter 4 Leaflet 4.1 Palettes 4.2 Mapping", " Chapter 4 Leaflet The final step is plotting our networks onto an interactive map! 4.1 Palettes We will need to create color schemes for our vertices pal1 &lt;- colorBin( palette = &quot;YlOrRd&quot;, domain = vert$deg, bins = 8 ) #pal for vert(G2) pal2 &lt;- colorBin( palette = &quot;YlOrRd&quot;, domain = vert_G2$deg, bins = 8 ) #pal for vert(G3) pal3 &lt;- colorBin( palette = &quot;YlOrRd&quot;, domain = vert_G3$deg, bins = 8 ) #pal for vert(G4) pal4 &lt;- colorBin( palette = &quot;YlOrRd&quot;, domain = vert_G4$deg, bins = 8 ) We also create popups for the map popup_stationName &lt;- station %&gt;% dplyr::select(&quot;Station.Id&quot;,&#39;StationName&#39;) %&gt;% dplyr::rename(&#39;Station Name&#39; = StationName) %&gt;% popupTable() 4.2 Mapping leaflet(vert) %&gt;% #basemaps addProviderTiles(providers$CartoDB.Positron, group = &quot;CartoDB&quot;)%&gt;% addTiles(group = &quot;OSM (default)&quot;) %&gt;% #Weekday 2019 #lines of most travelled stations addPolylines(data= edges, weight= network_extract$edges$n/50, color = &#39;purple&#39;, group = &quot;weekdays2019&quot;) %&gt;% #dots of the docks addCircles(data=vert, radius=10, weight=network_extract$vertices$deg/10, opacity=1,fillOpacity = 1,color = ~pal1(vert$deg), group = &quot;weekdays2019&quot;, popup = popup_stationName) %&gt;% #Weekend 2019 hideGroup(&quot;weekends2019&quot;)%&gt;% addPolylines(data= edges_G2, weight= network_extract_G2$edges$n/100, color = &#39;purple&#39;, group = &quot;weekends2019&quot;) %&gt;% addCircles(data=vert_G2, radius=10, weight=network_extract_G2$vertices$deg/3, opacity=1,fillOpacity = 1,color = ~pal2(vert_G2$deg), group = &quot;weekends2019&quot;, popup = popup_stationName) %&gt;% #Weekday 2020 hideGroup(&quot;weekdays2020&quot;)%&gt;% addPolylines(data= edges_G3, weight= network_extract_G3$edges$n/100, color = &#39;purple&#39;, group = &quot;weekdays2020&quot;) %&gt;% addCircles(data=vert_G3, radius=10, weight=network_extract_G3$vertices$deg/5, opacity=1,fillOpacity = 1,color = ~pal3(vert_G3$deg), group = &quot;weekdays2020&quot;, popup = popup_stationName) %&gt;% #Weekend 2020 hideGroup(&quot;weekends2020&quot;)%&gt;% addPolylines(data= edges_G4, weight= network_extract_G4$edges$n/100, color = &#39;purple&#39;, group = &quot;weekends2020&quot;) %&gt;% addCircles(data=vert_G4, radius=10, weight=network_extract_G4$vertices$deg/5, opacity=1,fillOpacity = 1,color = ~pal4(vert_G4$deg), group = &quot;weekends2020&quot;, popup = popup_stationName) %&gt;% # add a legend #wkday 2019 addLegend(pal = pal1, values = ~&#39;deg&#39;, group = &quot;weekdays2019&quot;, position =&quot;bottomleft&quot;, title = &quot;Total Degree&quot;, opacity = 0.9) %&gt;% #wkend 2019 addLegend(pal = pal2, values = ~&#39;deg&#39;, group = &quot;weekends2019&quot;, position =&quot;bottomleft&quot;, title = &quot;Total Degree&quot;, opacity = 0.9) %&gt;% #wkday 2020 addLegend(pal = pal3, values = ~&#39;deg&#39;, group = &quot;weekdays2020&quot;, position =&quot;bottomleft&quot;, title = &quot;Total Degree&quot;, opacity = 0.9) %&gt;% #wkend 2020 addLegend(pal = pal4, values = ~&#39;deg&#39;, group = &quot;weekends2020&quot;, position =&quot;bottomleft&quot;, title = &quot;Total Degree&quot;, opacity = 0.9) %&gt;% # specify layers control addLayersControl( baseGroups = c(&quot;CartoDB&quot;,&quot;OSM (default)&quot;,&quot;Carto (Positron)&quot;), overlayGroups = c(&quot;weekdays2019&quot;,&quot;weekends2019&quot;,&quot;weekdays2020&quot;,&quot;weekends2020&quot;), options = layersControlOptions(collapsed = F) ) "]]
